
P2617 Dynamic Rankings

渐入佳境

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define double long double
const ll N = 2e5+9 ;
const ll INF = 1e18 ;
// 前 i 个数字在 [x, y] 范围内的个数
// 当某一个位置修改以后后边的位置都要这样被修改
// 所以选择将原本T[i]版本主席树维护[1,i]区间数字信息
// 改为T[i]版本主席树维护[i-lowbit(i)+1,i]区间数字信息
// 从而实现log*log级别的单点修改
// 要离散化
struct node{
    int l , r , lson , rson , val ;
}t[N*400];
struct query{
    char op ;
    int a , b , c ;
}q[ N ];
int a[ N ] , b[ N ] , n , m , tot , idx , T[ N*400 ] ;
void Pushup( int p ){
    t[p].val = t[ t[p].lson ].val + t[ t[p].rson ].val ;
}
int Change( int p , int l , int r , int x , int val ){
    if( !p ){
        p = ++idx ; t[ p ].l = l ; t[ p ].r = r ;
    }
    if( l == r ){
        t[ p ].val += val ; return p ;
    }

    int mid = l+r >> 1 ;

    if( x <= mid ) t[p].lson = Change( t[p].lson , l , mid , x , val ) ;
    else t[p].rson = Change( t[p].rson , mid+1 , r , x , val ) ;

    Pushup( p ) ;
    return p ;
}
int Query( int p , int L , int R , int l , int r ){
    if( !p ) return 0 ;
    if( l <= L && R <= r ) return t[p].val ;

    int mid = L+R >> 1 ;
    int res = 0 ;

    if( l <= mid ) res += Query( t[p].lson , L , mid , l , r ) ;
    if( r > mid ) res += Query( t[p].rson , mid+1 , R , l , r ) ;

    return res ;
}
void Up( int i , int x , int val ){
    while( i <= tot ){
        T[i] = Change( T[i] , 1 , tot , x , val ) ;
        i += (i&-i) ;
    }
}
int Sum( int i , int l , int r ){
    int res = 0 ;
    while( i ){
        res += Query( T[i] , 1 , tot , l , r ) ; i -= (i&-i) ;
    }
    return res ;
}
int Find( int p1 , int p2 , int l , int r , int k ){
    if( l >= r ) return l ;

    int mid = l+r >> 1 ;

    int num = Sum( p2 , l , mid ) - Sum( p1 , l , mid ) ;
    if( num >= k ) return Find( p1 , p2 , l , mid , k ) ;
    else return Find( p1 , p2 , mid+1 , r , k-num ) ;
}
int main(){
    ios::sync_with_stdio(0); cin.tie(0);cout.tie(0);

    cin >> n >> m ;
    for( int i = 1 ; i <= n ; i ++ ){
        cin >> a[ i ] ; b[ ++tot ] = a[ i ] ;
    }

    for( int i = 1 ; i <= m ; i ++ ){
        cin >> q[i].op ;
        if( q[i].op == 'Q' ) cin >> q[i].a >> q[i].b >> q[i].c ;
        else{
            cin >> q[i].a >> q[i].b ; b[ ++tot ] = q[i].b ;
        }
    }

    sort( b+1 , b+1+tot ) ;
    tot = unique( b+1 , b+1+tot ) - b - 1 ;

    for( int i = 1 ; i <= n ; i ++ ){
        a[i] = lower_bound( b+1 , b+1+tot , a[i] ) - b ;
        //[i,n]版本a[i]位置都+1
        Up( i , a[i] , 1 ) ;
    }

    //cout << "?\n" ;

    for( int i = 1 ; i <= m ; i ++ ){
        if( q[i].op == 'Q' ){
            int l = q[i].a , r = q[i].b , k = q[i].c ;
            int ans = Find( l-1 , r , 1 , tot , k ) ;
            cout << b[ans] << "\n" ;
        }
        else{
            int x = q[i].a , y = q[i].b ;
            Up( x , a[x] , -1 ) ;
            a[x] = lower_bound( b+1 , b+1+tot , y ) - b ;
            Up( x , a[x] , 1 ) ;
        }
    }

    return 0 ;
}
/*

*/
```
